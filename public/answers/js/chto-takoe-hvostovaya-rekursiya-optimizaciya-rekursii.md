# Что такое хвостовая рекурсия? Оптимизация рекурсии?

Хвостовая рекурсия (tail recursion) — это особый вид рекурсии, при котором рекурсивный вызов является последней операцией в функции. Понимание хвостовой рекурсии критически важно для оптимизации рекурсивных функций и предотвращения переполнения стека.

## Что такое хвостовая рекурсия?

Хвостовая рекурсия — это рекурсия, при которой рекурсивный вызов является последней операцией перед возвратом значения.

### Характеристики:

- ✅ **Последняя операция** — рекурсивный вызов в конце функции
- ✅ **Оптимизация** — может быть оптимизирована компилятором
- ✅ **Экономия памяти** — не накапливает стек вызовов
- ✅ **Эквивалент итерации** — может быть преобразована в цикл

## Обычная рекурсия vs Хвостовая рекурсия

### Обычная рекурсия:

```javascript
// ❌ Не хвостовая рекурсия
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1); // Умножение после рекурсивного вызова
}

// Проблема: накапливает стек вызовов
// factorial(5) -> 5 * factorial(4) -> 5 * 4 * factorial(3) -> ...
```

### Хвостовая рекурсия:

```javascript
// ✅ Хвостовая рекурсия
function factorial(n, acc = 1) {
  if (n <= 1) return acc;
  return factorial(n - 1, n * acc); // Рекурсивный вызов - последняя операция
}

// Преимущество: может быть оптимизирована
// factorial(5, 1) -> factorial(4, 5) -> factorial(3, 20) -> ...
```

## Как работает оптимизация

### Без оптимизации:

```javascript
// Обычная рекурсия накапливает стек
function sum(n) {
  if (n <= 0) return 0;
  return n + sum(n - 1); // Нужно сохранить n в стеке
}

// Call stack для sum(5):
// sum(5) -> 5 + sum(4)
// sum(4) -> 4 + sum(3)
// sum(3) -> 3 + sum(2)
// sum(2) -> 2 + sum(1)
// sum(1) -> 1 + sum(0)
// sum(0) -> 0
// Затем вычисление: 1 + 0 = 1, 2 + 1 = 3, ...
```

### С оптимизацией (TCO - Tail Call Optimization):

```javascript
// Хвостовая рекурсия может быть оптимизирована
function sum(n, acc = 0) {
  if (n <= 0) return acc;
  return sum(n - 1, n + acc); // Не нужно сохранять в стеке
}

// С оптимизацией TCO:
// sum(5, 0) -> sum(4, 5) -> sum(3, 9) -> sum(2, 12) -> sum(1, 14) -> sum(0, 15) -> 15
// Стек не накапливается, каждый вызов заменяет предыдущий
```

## Практические примеры

### Пример 1: Факториал

```javascript
// ❌ Обычная рекурсия
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1); // Не хвостовая
}

// ✅ Хвостовая рекурсия
function factorial(n, acc = 1) {
  if (n <= 1) return acc;
  return factorial(n - 1, n * acc); // Хвостовая
}

factorial(5); // 120
```

### Пример 2: Сумма чисел

```javascript
// ❌ Обычная рекурсия
function sum(n) {
  if (n <= 0) return 0;
  return n + sum(n - 1); // Не хвостовая
}

// ✅ Хвостовая рекурсия
function sum(n, acc = 0) {
  if (n <= 0) return acc;
  return sum(n - 1, n + acc); // Хвостовая
}

sum(5); // 15
```

### Пример 3: Фибоначчи

```javascript
// ❌ Обычная рекурсия (неэффективная)
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2); // Не хвостовая
}

// ✅ Хвостовая рекурсия (эффективная)
function fibonacci(n, a = 0, b = 1) {
  if (n === 0) return a;
  if (n === 1) return b;
  return fibonacci(n - 1, b, a + b); // Хвостовая
}

fibonacci(10); // 55
```

### Пример 4: Обращение массива

```javascript
// ❌ Обычная рекурсия
function reverse(arr) {
  if (arr.length <= 1) return arr;
  return [arr[arr.length - 1], ...reverse(arr.slice(0, -1))]; // Не хвостовая
}

// ✅ Хвостовая рекурсия
function reverse(arr, result = []) {
  if (arr.length === 0) return result;
  return reverse(arr.slice(1), [arr[0], ...result]); // Хвостовая
}

reverse([1, 2, 3, 4, 5]); // [5, 4, 3, 2, 1]
```

## Преобразование в хвостовую рекурсию

### Шаги преобразования:

1. **Добавить аккумулятор** — для накопления результата
2. **Переместить вычисления** — в параметры функции
3. **Сделать рекурсивный вызов** — последней операцией

```javascript
// Шаг 1: Исходная функция
function sum(n) {
  if (n <= 0) return 0;
  return n + sum(n - 1);
}

// Шаг 2: Добавить аккумулятор
function sum(n, acc = 0) {
  if (n <= 0) return acc;
  // Переместить вычисление в параметр
  return sum(n - 1, n + acc);
}
```

## TCO (Tail Call Optimization)

### Что такое TCO?

TCO — это оптимизация компилятора, которая преобразует хвостовую рекурсию в итерацию, избегая накопления стека вызовов.

### Поддержка в JavaScript:

```javascript
// TCO поддерживается в строгом режиме в некоторых движках
"use strict";

function factorial(n, acc = 1) {
  if (n <= 1) return acc;
  return factorial(n - 1, n * acc); // Может быть оптимизирована
}

// В движках без TCO все равно накапливается стек
// В движках с TCO преобразуется в цикл
```

## Альтернатива: Итерация

### Когда TCO недоступна:

```javascript
// ✅ Использование итерации вместо рекурсии
function factorial(n) {
  let result = 1;
  for (let i = 2; i <= n; i++) {
    result *= i;
  }
  return result;
}

// Преимущества:
// - Всегда работает
// - Не накапливает стек
// - Предсказуемая производительность
```

## Лучшие практики

### ✅ Делайте:

1. **Используйте хвостовую рекурсию** — когда возможно
2. **Добавляйте аккумуляторы** — для накопления результата
3. **Используйте итерацию** — когда TCO недоступна
4. **Тестируйте производительность** — сравнивайте подходы

### ❌ Не делайте:

1. **Не полагайтесь на TCO** — не все движки поддерживают
2. **Не используйте рекурсию** — для очень глубоких вызовов
3. **Не забывайте про аккумуляторы** — для хвостовой рекурсии
4. **Не усложняйте** — итерация часто проще

## Заключение

Хвостовая рекурсия:

- **Последняя операция** — рекурсивный вызов в конце функции
- **Оптимизация** — может быть оптимизирована компилятором (TCO)
- **Экономия памяти** — не накапливает стек вызовов
- **Преобразование** — добавление аккумулятора

**Помните:** хвостовая рекурсия — это рекурсия, где рекурсивный вызов является последней операцией. Она может быть оптимизирована компилятором (TCO), но не все движки поддерживают эту оптимизацию. Используйте хвостовую рекурсию когда возможно, но предпочитайте итерацию для критической производительности. Понимание хвостовой рекурсии критически важно для оптимизации рекурсивных функций.

