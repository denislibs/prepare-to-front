# Что такое и как работает `debounce()` и `throttle()` в JavaScript?

`debounce()` и `throttle()` — это две техники оптимизации производительности, которые ограничивают частоту выполнения функций. Понимание этих техник критически важно для оптимизации обработки событий и улучшения производительности приложений.

## Что такое debounce?

`debounce()` — это техника, которая откладывает выполнение функции до тех пор, пока не пройдет определенное время с момента последнего вызова.

### Характеристики:

- ✅ **Откладывает выполнение** — ждет паузы в вызовах
- ✅ **Сбрасывает таймер** — при каждом новом вызове
- ✅ **Выполняет один раз** — после паузы
- ✅ **Для поиска** — идеально для поиска в реальном времени

### Как работает:

```javascript
// Пользователь вводит "hello"
// debounce с задержкой 300ms:
// h -> таймер 300ms
// e -> сброс таймера, новый таймер 300ms
// l -> сброс таймера, новый таймер 300ms
// l -> сброс таймера, новый таймер 300ms
// o -> сброс таймера, новый таймер 300ms
// (пауза 300ms) -> выполнение функции
```

## Что такое throttle?

`throttle()` — это техника, которая ограничивает частоту выполнения функции, выполняя ее не чаще одного раза за определенный интервал времени.

### Характеристики:

- ✅ **Ограничивает частоту** — максимум один раз за интервал
- ✅ **Не сбрасывает таймер** — игнорирует вызовы во время ожидания
- ✅ **Выполняет регулярно** — через равные интервалы
- ✅ **Для скролла** — идеально для обработки скролла

### Как работает:

```javascript
// Пользователь скроллит страницу
// throttle с интервалом 300ms:
// скролл -> выполнение (сразу)
// скролл -> игнорируется (0-300ms)
// скролл -> игнорируется (0-300ms)
// (прошло 300ms) -> выполнение
// скролл -> выполнение (сразу)
// скролл -> игнорируется (0-300ms)
```

## Реализация debounce

### Базовая реализация:

```javascript
function debounce(func, delay) {
  let timeoutId;
  
  return function(...args) {
    const context = this;
    
    // Очистка предыдущего таймера
    clearTimeout(timeoutId);
    
    // Установка нового таймера
    timeoutId = setTimeout(() => {
      func.apply(context, args);
    }, delay);
  };
}
```

### Использование:

```javascript
// Функция поиска
function search(query) {
  console.log("Searching for:", query);
}

// Создание debounced версии
const debouncedSearch = debounce(search, 300);

// Вызовы
debouncedSearch("h"); // Таймер 300ms
debouncedSearch("he"); // Сброс, новый таймер 300ms
debouncedSearch("hel"); // Сброс, новый таймер 300ms
debouncedSearch("hell"); // Сброс, новый таймер 300ms
debouncedSearch("hello"); // Сброс, новый таймер 300ms
// (пауза 300ms) -> выполнение search("hello")
```

## Реализация throttle

### Базовая реализация:

```javascript
function throttle(func, limit) {
  let inThrottle;
  
  return function(...args) {
    const context = this;
    
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => {
        inThrottle = false;
      }, limit);
    }
  };
}
```

### Улучшенная реализация:

```javascript
function throttle(func, limit) {
  let lastFunc;
  let lastRan;
  
  return function(...args) {
    const context = this;
    
    if (!lastRan) {
      // Первый вызов - выполнить сразу
      func.apply(context, args);
      lastRan = Date.now();
    } else {
      // Очистка предыдущего отложенного вызова
      clearTimeout(lastFunc);
      
      // Установка нового отложенного вызова
      lastFunc = setTimeout(() => {
        if ((Date.now() - lastRan) >= limit) {
          func.apply(context, args);
          lastRan = Date.now();
        }
      }, limit - (Date.now() - lastRan));
    }
  };
}
```

### Использование:

```javascript
// Функция обработки скролла
function handleScroll() {
  console.log("Scrolling");
}

// Создание throttled версии
const throttledScroll = throttle(handleScroll, 300);

// Вызовы
throttledScroll(); // Выполнение (сразу)
throttledScroll(); // Игнорируется (0-300ms)
throttledScroll(); // Игнорируется (0-300ms)
// (прошло 300ms)
throttledScroll(); // Выполнение (сразу)
```

## Практические примеры

### Пример 1: Поиск в реальном времени

```javascript
// ✅ Использование debounce для поиска
const searchInput = document.querySelector("#search");

const debouncedSearch = debounce((query) => {
  // Выполнение поиска только после паузы
  performSearch(query);
}, 300);

searchInput.addEventListener("input", (e) => {
  debouncedSearch(e.target.value);
});
```

### Пример 2: Обработка скролла

```javascript
// ✅ Использование throttle для скролла
const throttledScroll = throttle(() => {
  // Обработка скролла не чаще раза в 100ms
  updateScrollPosition();
}, 100);

window.addEventListener("scroll", throttledScroll);
```

### Пример 3: Обработка изменения размера окна

```javascript
// ✅ Использование debounce для resize
const debouncedResize = debounce(() => {
  // Выполнение только после окончания изменения размера
  recalculateLayout();
}, 250);

window.addEventListener("resize", debouncedResize);
```

### Пример 4: Кнопка отправки формы

```javascript
// ✅ Использование debounce для предотвращения двойной отправки
const submitButton = document.querySelector("#submit");

const debouncedSubmit = debounce(() => {
  submitForm();
}, 1000);

submitButton.addEventListener("click", debouncedSubmit);
```

## Сравнение debounce и throttle

### Визуальное сравнение:

```
События:  |--1--2--3--4--5--6--7--8--9--|
          |                             |
debounce: |-----------------------------9| (выполнение после паузы)
          |                             |
throttle: |1-----4-----7-----9----------| (выполнение через интервалы)
```

### Когда использовать debounce:

- ✅ **Поиск в реальном времени** — ждать окончания ввода
- ✅ **Валидация формы** — после окончания ввода
- ✅ **Изменение размера окна** — после окончания изменения
- ✅ **Кнопки** — предотвращение двойных кликов

### Когда использовать throttle:

- ✅ **Обработка скролла** — регулярное обновление
- ✅ **Обработка движения мыши** — ограничение частоты
- ✅ **Игровые события** — ограничение частоты обновлений
- ✅ **API запросы** — ограничение частоты запросов

## Лучшие практики

### ✅ Делайте:

1. **Используйте debounce** — для событий, которые должны выполняться после паузы
2. **Используйте throttle** — для событий, которые должны выполняться регулярно
3. **Выбирайте правильную задержку** — баланс между отзывчивостью и производительностью
4. **Тестируйте производительность** — измеряйте влияние на производительность

### ❌ Не делайте:

1. **Не используйте везде** — только когда нужно
2. **Не забывайте про контекст** — используйте apply/call
3. **Не используйте слишком короткие задержки** — может не помочь
4. **Не используйте слишком длинные задержки** — ухудшает UX

## Заключение

`debounce()` и `throttle()`:

- **debounce** — откладывает выполнение до паузы
- **throttle** — ограничивает частоту выполнения
- **Применение** — оптимизация обработки событий
- **Производительность** — улучшение производительности приложений

**Помните:** `debounce()` откладывает выполнение функции до паузы в вызовах, а `throttle()` ограничивает частоту выполнения функции. Используйте `debounce()` для поиска и валидации, а `throttle()` для скролла и движения мыши. Понимание этих техник критически важно для оптимизации производительности JavaScript приложений.

