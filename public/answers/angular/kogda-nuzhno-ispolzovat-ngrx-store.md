# Когда нужно использовать ngrx/store?

NgRx Store — это библиотека управления состоянием для Angular приложений, основанная на паттерне Redux. Решение о том, когда использовать NgRx Store, является одним из важнейших архитектурных решений при разработке Angular приложений. Понимание того, когда NgRx Store принесет пользу, а когда он будет избыточным, поможет создать правильную архитектуру приложения и избежать ненужной сложности.

## Что такое NgRx Store?

NgRx Store — это реактивная библиотека управления состоянием, которая использует паттерн Redux для централизованного управления состоянием приложения. Она предоставляет предсказуемый способ управления состоянием через единый источник истины (single source of truth) и неизменяемые обновления состояния.

### Основные концепции:

- **Store** — централизованное хранилище состояния
- **Actions** — события, которые описывают что произошло
- **Reducers** — чистые функции, которые определяют как состояние изменяется
- **Selectors** — функции для извлечения данных из состояния
- **Effects** — побочные эффекты (например, HTTP запросы)

## Когда НУЖНО использовать NgRx Store?

### 1. **Большие и сложные приложения**

Когда приложение становится достаточно большим и сложным, управление состоянием через сервисы и компоненты становится трудным и подверженным ошибкам.

**Признаки:**
- Множество компонентов, которые должны обмениваться данными
- Сложная логика управления состоянием
- Трудность отслеживания потока данных
- Множество взаимосвязанных состояний

**Пример:**
```typescript
// Без NgRx - состояние разбросано по сервисам
@Injectable()
export class UserService {
  private users: User[] = [];
  private selectedUser: User | null = null;
  private loading = false;
  // Множество методов для управления состоянием
}

@Injectable()
export class ProductService {
  private products: Product[] = [];
  private cart: CartItem[] = [];
  // Еще больше состояния
}

// С NgRx - централизованное состояние
interface AppState {
  users: UserState;
  products: ProductState;
  cart: CartState;
}
```

### 2. **Необходимость отладки и отслеживания изменений**

NgRx Store предоставляет мощные инструменты для отладки, включая Redux DevTools, которые позволяют видеть все изменения состояния, путешествовать во времени и отлаживать приложение.

**Преимущества:**
- История всех действий
- Возможность "путешествия во времени"
- Предсказуемые изменения состояния
- Легкая отладка

**Пример использования DevTools:**
```typescript
// Все действия логируются автоматически
// Можно видеть:
// 1. Какое действие было вызвано
// 2. Какое состояние было до действия
// 3. Какое состояние стало после
// 4. Какие данные были переданы
```

### 3. **Сложная бизнес-логика и побочные эффекты**

Когда приложение имеет сложную бизнес-логику с множеством побочных эффектов (HTTP запросы, WebSocket соединения, таймеры), NgRx Effects предоставляет централизованный способ управления ими.

**Пример:**
```typescript
// Сложная логика с побочными эффектами
@Injectable()
export class OrderEffects {
  createOrder$ = createEffect(() =>
    this.actions$.pipe(
      ofType(OrderActions.createOrder),
      switchMap(action =>
        this.orderService.createOrder(action.order).pipe(
          map(order => OrderActions.createOrderSuccess({ order })),
          catchError(error => of(OrderActions.createOrderFailure({ error })))
        )
      )
    )
  );
  
  // Автоматическая обработка успеха/ошибки
  // Централизованная логика
}
```

### 4. **Необходимость синхронизации состояния между компонентами**

Когда множество компонентов должны иметь доступ к одному и тому же состоянию и реагировать на его изменения, NgRx Store обеспечивает эффективную синхронизацию.

**Пример:**
```typescript
// Компонент A
@Component({...})
export class ComponentA {
  constructor(private store: Store) {}
  
  addItem(item: Item) {
    this.store.dispatch(ItemActions.addItem({ item }));
  }
}

// Компонент B (в другом месте приложения)
@Component({...})
export class ComponentB {
  items$ = this.store.select(selectAllItems);
  
  // Автоматически обновится при изменении состояния
}
```

### 5. **Необходимость отмены/повтора действий (Undo/Redo)**

NgRx Store с его неизменяемым состоянием и историей действий идеально подходит для реализации функциональности отмены/повтора.

**Пример:**
```typescript
// Можно легко реализовать undo/redo
// Сохраняя историю состояний
interface AppState {
  past: State[];
  present: State;
  future: State[];
}
```

### 6. **Совместная работа команды**

Когда над проектом работает большая команда разработчиков, NgRx Store обеспечивает единообразный подход к управлению состоянием, что упрощает совместную работу.

**Преимущества:**
- Единый паттерн для всех разработчиков
- Легче понять код других разработчиков
- Меньше конфликтов при слиянии кода
- Четкая структура проекта

## Когда НЕ НУЖНО использовать NgRx Store?

### 1. **Маленькие и простые приложения**

Для простых приложений с минимальным состоянием NgRx Store будет избыточным и добавит ненужную сложность.

**Пример простого приложения:**
```typescript
// Простое приложение - NgRx не нужен
@Component({...})
export class SimpleComponent {
  items: string[] = [];
  
  addItem(item: string) {
    this.items.push(item);
  }
}
```

### 2. **Простое локальное состояние компонента**

Состояние, которое используется только в одном компоненте, не требует NgRx Store.

**Пример:**
```typescript
// Локальное состояние - не нужно в Store
@Component({...})
export class LocalComponent {
  isOpen = false; // Используется только здесь
  localData: any; // Используется только здесь
}
```

### 3. **Простая передача данных между родителем и ребенком**

Для простой передачи данных между родительским и дочерним компонентом достаточно использовать `@Input()` и `@Output()`.

**Пример:**
```typescript
// Простая передача данных - не нужен NgRx
@Component({...})
export class ParentComponent {
  data = 'Данные';
}

@Component({...})
export class ChildComponent {
  @Input() data: string = '';
  @Output() dataChange = new EventEmitter<string>();
}
```

### 4. **Простое кеширование данных**

Для простого кеширования данных достаточно использовать сервис с BehaviorSubject.

**Пример:**
```typescript
// Простое кеширование - не нужен NgRx
@Injectable()
export class DataService {
  private cache$ = new BehaviorSubject<Data[]>([]);
  
  getData() {
    if (this.cache$.value.length === 0) {
      this.loadData();
    }
    return this.cache$.asObservable();
  }
}
```

## Альтернативы NgRx Store

### 1. **Сервисы с BehaviorSubject**

Для средних приложений достаточно использовать сервисы с BehaviorSubject.

```typescript
@Injectable({
  providedIn: 'root'
})
export class StateService {
  private state$ = new BehaviorSubject<AppState>(initialState);
  
  getState$() {
    return this.state$.asObservable();
  }
  
  updateState(newState: Partial<AppState>) {
    this.state$.next({ ...this.state$.value, ...newState });
  }
}
```

### 2. **Akita**

Альтернативная библиотека управления состоянием, более простая чем NgRx.

### 3. **NgRx Component Store**

Легковесная версия NgRx для управления локальным состоянием компонента.

```typescript
@Component({...})
export class MyComponent {
  private store = new ComponentStore<ComponentState>({
    items: [],
    loading: false
  });
  
  items$ = this.store.select(state => state.items);
}
```

## Практические рекомендации

### Используйте NgRx Store когда:

✅ Приложение большое и сложное  
✅ Множество компонентов обмениваются данными  
✅ Нужна отладка и отслеживание изменений  
✅ Сложная бизнес-логика с побочными эффектами  
✅ Нужна функциональность undo/redo  
✅ Большая команда разработчиков  

### НЕ используйте NgRx Store когда:

❌ Приложение маленькое и простое  
❌ Состояние используется только локально  
❌ Простая передача данных между компонентами  
❌ Простое кеширование данных  
❌ Нет необходимости в сложной отладке  

## Пример принятия решения

### Сценарий 1: Простое приложение-калькулятор

```typescript
// ❌ NgRx избыточен
// Достаточно простого компонента
@Component({...})
export class CalculatorComponent {
  result = 0;
  
  add(a: number, b: number) {
    this.result = a + b;
  }
}
```

### Сценарий 2: Среднее приложение с несколькими страницами

```typescript
// ✅ Сервис с BehaviorSubject достаточно
@Injectable()
export class AppStateService {
  private state$ = new BehaviorSubject<AppState>(initialState);
  // ...
}
```

### Сценарий 3: Большое корпоративное приложение

```typescript
// ✅ NgRx Store необходим
// Множество модулей, сложная логика, команда разработчиков
// Централизованное управление состоянием критично
```

## Миграция на NgRx Store

Если вы решили использовать NgRx Store, вот пошаговый подход:

1. **Начните с малого** — добавьте Store для одного модуля
2. **Постепенно расширяйте** — добавляйте новые части состояния
3. **Рефакторинг** — переносите существующую логику в Store
4. **Обучение команды** — убедитесь, что все понимают паттерн

## Заключение

NgRx Store следует использовать когда:

- **Приложение большое и сложное** — нужна централизация состояния
- **Сложная бизнес-логика** — нужны Effects для побочных эффектов
- **Множество компонентов** — нужна синхронизация состояния
- **Отладка важна** — нужны инструменты для отслеживания изменений
- **Команда разработчиков** — нужен единый подход

**Помните:** NgRx Store — это мощный инструмент, но он добавляет сложность. Используйте его только когда преимущества перевешивают затраты на сложность. Для большинства приложений достаточно сервисов с BehaviorSubject или простых компонентов с локальным состоянием. Не используйте NgRx Store только потому, что это "современный подход" — используйте его когда он действительно нужен.

