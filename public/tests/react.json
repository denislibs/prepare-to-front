{
  "topic": "react",
  "title": "Тест по React",
  "questions": [
    {
      "id": "react-1",
      "text": "Что такое React?",
      "type": "multiple-choice",
      "options": [
        "Язык программирования",
        "JavaScript-библиотека для создания пользовательских интерфейсов",
        "Фреймворк для создания серверных приложений",
        "База данных"
      ],
      "correctAnswer": 1
    },
    {
      "id": "react-2",
      "text": "Что такое Virtual DOM?",
      "type": "multiple-choice",
      "options": [
        "Метод оптимизации CSS",
        "Виртуальное представление реального DOM в памяти",
        "Браузерный API",
        "Специальный тип DOM-элемента"
      ],
      "correctAnswer": 1
    },
    {
      "id": "react-3",
      "text": "Для чего нужен атрибут `key` при рендере списков?",
      "type": "multiple-choice",
      "options": [
        "Для стилизации элементов",
        "Для добавления обработчиков событий",
        "Для условного рендеринга",
        "Для идентификации элементов и эффективного обновления DOM"
      ],
      "correctAnswer": 3
    },
    {
      "id": "react-4",
      "text": "Что такое `PureComponent`?",
      "type": "multiple-choice",
      "options": [
        "Компонент только с пропсами",
        "Компонент с автоматическим поверхностным сравнением пропсов и состояния",
        "Функциональный компонент",
        "Компонент без состояния"
      ],
      "correctAnswer": 1
    },
    {
      "id": "react-5",
      "text": "Что такое HOC (Higher-Order Component)?",
      "type": "multiple-choice",
      "options": [
        "Компонент с множеством пропсов",
        "Функция, которая принимает компонент и возвращает новый компонент",
        "Базовый класс компонента",
        "Компонент высшего уровня в иерархии"
      ],
      "correctAnswer": 1
    },
    {
      "id": "react-6",
      "text": "Разница между управляемыми и неуправляемыми компонентами?",
      "type": "multiple-choice",
      "options": [
        "Управляемые контролируются React через state, неуправляемые через DOM",
        "Управляемые быстрее, неуправляемые медленнее",
        "Нет разницы",
        "Управляемые только для форм, неуправляемые для всего остального"
      ],
      "correctAnswer": 0
    },
    {
      "id": "react-7",
      "text": "Какой метод жизненного цикла вызывается после монтирования компонента?",
      "type": "multiple-choice",
      "options": [
        "componentWillUnmount",
        "componentDidUpdate",
        "componentWillMount",
        "componentDidMount"
      ],
      "correctAnswer": 3
    },
    {
      "id": "react-8",
      "text": "Что такое React Reconciliation?",
      "type": "multiple-choice",
      "options": [
        "Метод оптимизации производительности",
        "Синхронизация состояния между компонентами",
        "Процесс сравнения виртуальных деревьев и обновления DOM",
        "Объединение нескольких компонентов"
      ],
      "correctAnswer": 2
    },
    {
      "id": "react-9",
      "text": "Что такое Portal в React?",
      "type": "multiple-choice",
      "options": [
        "Способ рендеринга элементов вне родительского DOM-дерева",
        "Тип компонента",
        "Метод маршрутизации",
        "Способ передачи данных между компонентами"
      ],
      "correctAnswer": 0
    },
    {
      "id": "react-10",
      "text": "Что такое Context в React?",
      "type": "multiple-choice",
      "options": [
        "Механизм передачи данных через дерево компонентов без prop drilling",
        "Тип компонента",
        "Метод стилизации",
        "Библиотека для управления состоянием"
      ],
      "correctAnswer": 0
    },
    {
      "id": "react-11",
      "text": "Что такое React Hooks?",
      "type": "multiple-choice",
      "options": [
        "Типы данных React",
        "События React",
        "Методы классовых компонентов",
        "Функции для использования возможностей React в функциональных компонентах"
      ],
      "correctAnswer": 3
    },
    {
      "id": "react-12",
      "text": "Что такое JSX?",
      "type": "multiple-choice",
      "options": [
        "Синтаксическое расширение JavaScript для описания UI",
        "Новый язык программирования",
        "Библиотека для работы с DOM",
        "Метод оптимизации"
      ],
      "correctAnswer": 0
    },
    {
      "id": "react-13",
      "text": "Разница между JSX и HTML?",
      "type": "multiple-choice",
      "options": [
        "JSX использует camelCase для атрибутов и компилируется в JavaScript",
        "JSX медленнее HTML",
        "Нет разницы",
        "HTML компилируется в JSX"
      ],
      "correctAnswer": 0
    },
    {
      "id": "react-14",
      "text": "Разница между state и props?",
      "type": "multiple-choice",
      "options": [
        "State изменяем, props неизменяем",
        "State - внутреннее состояние компонента, props - данные от родителя",
        "Нет разницы",
        "State только для классовых компонентов, props для функциональных"
      ],
      "correctAnswer": 1
    },
    {
      "id": "react-15",
      "text": "Что такое React Fiber?",
      "type": "multiple-choice",
      "options": [
        "Тип компонента",
        "Библиотека для анимаций",
        "Метод стилизации",
        "Новая архитектура reconciliation с инкрементальным рендерингом"
      ],
      "correctAnswer": 3
    },
    {
      "id": "react-16",
      "text": "Почему Fragment лучше, чем div?",
      "type": "multiple-choice",
      "options": [
        "Нет разницы",
        "Fragment поддерживает стили, div нет",
        "Fragment не создает дополнительный DOM-узел",
        "Fragment быстрее div"
      ],
      "correctAnswer": 2
    },
    {
      "id": "react-17",
      "text": "Что такое синтетические события в React?",
      "type": "multiple-choice",
      "options": [
        "Обертки над нативными событиями для кроссбраузерной совместимости",
        "Асинхронные события",
        "Специальные события React",
        "События только для мобильных устройств"
      ],
      "correctAnswer": 0
    },
    {
      "id": "react-18",
      "text": "Что такое ref в React?",
      "type": "multiple-choice",
      "options": [
        "Способ получить прямой доступ к DOM-элементу или экземпляру компонента",
        "Метод маршрутизации",
        "Ссылка на другой компонент",
        "Тип пропса"
      ],
      "correctAnswer": 0
    },
    {
      "id": "react-19",
      "text": "Разница между Shadow DOM и Virtual DOM?",
      "type": "multiple-choice",
      "options": [
        "Shadow DOM быстрее Virtual DOM",
        "Virtual DOM часть Shadow DOM",
        "Shadow DOM - инкапсуляция, Virtual DOM - оптимизация обновлений",
        "Нет разницы"
      ],
      "correctAnswer": 2
    },
    {
      "id": "react-20",
      "text": "Что такое условный рендеринг?",
      "type": "multiple-choice",
      "options": [
        "Рендеринг только при определенных условиях",
        "Метод оптимизации",
        "Условное применение стилей",
        "Отображение разных элементов в зависимости от условий"
      ],
      "correctAnswer": 3
    },
    {
      "id": "react-21",
      "text": "Разница между React и ReactDOM?",
      "type": "multiple-choice",
      "options": [
        "React для сервера, ReactDOM для клиента",
        "React - логика библиотеки, ReactDOM - рендеринг в DOM",
        "React устарел, используется только ReactDOM",
        "Нет разницы"
      ],
      "correctAnswer": 1
    },
    {
      "id": "react-22",
      "text": "Разница между компонентом и контейнером?",
      "type": "multiple-choice",
      "options": [
        "Компонент - представление, контейнер - логика и состояние",
        "Компонент для функциональных, контейнер для классовых",
        "Компонент быстрее контейнера",
        "Нет разницы"
      ],
      "correctAnswer": 0
    },
    {
      "id": "react-23",
      "text": "Как React ограничивает использование пропсов определенного типа?",
      "type": "multiple-choice",
      "options": [
        "Не ограничивает",
        "Автоматически",
        "Через PropTypes или TypeScript",
        "Через специальные атрибуты"
      ],
      "correctAnswer": 2
    },
    {
      "id": "react-24",
      "text": "Что такое Strict Mode в React?",
      "type": "multiple-choice",
      "options": [
        "Режим только для продакшена",
        "Метод оптимизации",
        "Инструмент для выявления потенциальных проблем в приложении",
        "Тип компонента"
      ],
      "correctAnswer": 2
    },
    {
      "id": "react-25",
      "text": "Что такое Prop Drilling?",
      "type": "multiple-choice",
      "options": [
        "Метод оптимизации пропсов",
        "Передача данных через множество уровней компонентов",
        "Тип компонента",
        "Библиотека для работы с пропсами"
      ],
      "correctAnswer": 1
    },
    {
      "id": "react-26",
      "text": "Что такое Polling в React?",
      "type": "multiple-choice",
      "options": [
        "Метод рендеринга",
        "Тип компонента",
        "Периодический запрос данных с сервера",
        "Библиотека для запросов"
      ],
      "correctAnswer": 2
    },
    {
      "id": "react-27",
      "text": "Разница между элементом и компонентом?",
      "type": "multiple-choice",
      "options": [
        "Элемент быстрее компонента",
        "Элемент - описание, компонент - функция или класс",
        "Элемент для HTML, компонент для React",
        "Нет разницы"
      ],
      "correctAnswer": 1
    },
    {
      "id": "react-28",
      "text": "Что такое ReactDOMServer?",
      "type": "multiple-choice",
      "options": [
        "API для серверного рендеринга React-компонентов",
        "Серверный компонент React",
        "Метод оптимизации",
        "Библиотека для работы с сервером"
      ],
      "correctAnswer": 0
    },
    {
      "id": "react-29",
      "text": "Что такое Error Boundaries?",
      "type": "multiple-choice",
      "options": [
        "Метод обработки ошибок",
        "Библиотека для ошибок",
        "Тип компонента",
        "Компоненты для перехвата ошибок в дочерних компонентах"
      ],
      "correctAnswer": 3
    },
    {
      "id": "react-30",
      "text": "Что такое React.lazy?",
      "type": "multiple-choice",
      "options": [
        "Библиотека для загрузки",
        "Тип компонента",
        "Метод оптимизации",
        "Функция для ленивой загрузки компонентов"
      ],
      "correctAnswer": 3
    },
    {
      "id": "react-31",
      "text": "Разница между рендерингом и монтированием?",
      "type": "multiple-choice",
      "options": [
        "Нет разницы",
        "Рендеринг - создание виртуального DOM, монтирование - вставка в реальный DOM",
        "Рендеринг быстрее монтирования",
        "Рендеринг на сервере, монтирование на клиенте"
      ],
      "correctAnswer": 1
    },
    {
      "id": "react-32",
      "text": "Что такое children в React?",
      "type": "multiple-choice",
      "options": [
        "Тип данных",
        "Библиотека для работы с элементами",
        "Метод компонента",
        "Специальный проп для дочерних элементов"
      ],
      "correctAnswer": 3
    },
    {
      "id": "react-33",
      "text": "Что такое Pointer Events?",
      "type": "multiple-choice",
      "options": [
        "События только для мыши",
        "События только для touch",
        "Специальные события React",
        "Унифицированные события для различных типов указательных устройств"
      ],
      "correctAnswer": 3
    },
    {
      "id": "react-34",
      "text": "Что такое Inheritance Inversion?",
      "type": "multiple-choice",
      "options": [
        "Библиотека для наследования",
        "Паттерн HOC с наследованием от переданного компонента",
        "Тип компонента",
        "Метод оптимизации"
      ],
      "correctAnswer": 1
    },
    {
      "id": "react-35",
      "text": "Как реализовать двустороннее связывание данных в React?",
      "type": "multiple-choice",
      "options": [
        "Автоматически",
        "Через управляемые компоненты и обработчики событий",
        "Нельзя реализовать",
        "Только через библиотеки"
      ],
      "correctAnswer": 1
    },
    {
      "id": "react-36",
      "text": "Разница между классовым и функциональным компонентами?",
      "type": "multiple-choice",
      "options": [
        "Функциональные устарели",
        "Нет разницы",
        "Классовые используют классы и методы жизненного цикла, функциональные используют хуки",
        "Классовые быстрее функциональных"
      ],
      "correctAnswer": 2
    },
    {
      "id": "react-37",
      "text": "Разница между useEffect и componentDidMount?",
      "type": "multiple-choice",
      "options": [
        "Нет разницы",
        "componentDidMount устарел",
        "useEffect - хук для функциональных компонентов, componentDidMount - метод классовых",
        "useEffect быстрее componentDidMount"
      ],
      "correctAnswer": 2
    },
    {
      "id": "react-38",
      "text": "Преимущества хуков?",
      "type": "multiple-choice",
      "options": [
        "Только для функциональных компонентов",
        "Нет преимуществ",
        "Быстрее классовых компонентов",
        "Переиспользование логики, меньше кода, проще понять"
      ],
      "correctAnswer": 3
    },
    {
      "id": "react-39",
      "text": "Недостатки хуков?",
      "type": "multiple-choice",
      "options": [
        "Только для простых компонентов",
        "Правила использования, кривая обучения, сложность отладки",
        "Нет недостатков",
        "Медленнее классовых компонентов"
      ],
      "correctAnswer": 1
    },
    {
      "id": "react-40",
      "text": "Правила использования хуков?",
      "type": "multiple-choice",
      "options": [
        "Вызывать только на верхнем уровне и только из React-функций",
        "Только в классовых компонентах",
        "Нет правил",
        "Можно вызывать где угодно"
      ],
      "correctAnswer": 0
    },
    {
      "id": "react-41",
      "text": "Что такое Lifting State Up?",
      "type": "multiple-choice",
      "options": [
        "Метод оптимизации состояния",
        "Перемещение состояния из дочернего компонента в родительский",
        "Тип компонента",
        "Библиотека для состояния"
      ],
      "correctAnswer": 1
    },
    {
      "id": "react-42",
      "text": "Что делает метод shouldComponentUpdate?",
      "type": "multiple-choice",
      "options": [
        "Вызывается при монтировании",
        "Определяет, нужно ли перерисовывать компонент",
        "Обновляет состояние",
        "Обрабатывает события"
      ],
      "correctAnswer": 1
    },
    {
      "id": "react-43",
      "text": "Разница между createElement и cloneElement?",
      "type": "multiple-choice",
      "options": [
        "createElement быстрее cloneElement",
        "Нет разницы",
        "cloneElement устарел",
        "createElement создает новый элемент, cloneElement клонирует существующий"
      ],
      "correctAnswer": 3
    },
    {
      "id": "react-44",
      "text": "Что такое useReducer?",
      "type": "multiple-choice",
      "options": [
        "Тип компонента",
        "Библиотека для состояния",
        "Метод оптимизации",
        "Хук для управления сложным состоянием через паттерн reducer"
      ],
      "correctAnswer": 3
    },
    {
      "id": "react-45",
      "text": "Как реализовать однократное выполнение операции при начальном рендеринге?",
      "type": "multiple-choice",
      "options": [
        "Использовать componentDidMount",
        "Использовать useEffect с пустым массивом зависимостей",
        "Использовать useMemo",
        "Нельзя реализовать"
      ],
      "correctAnswer": 1
    },
    {
      "id": "react-46",
      "text": "Что такое распределенный компонент?",
      "type": "multiple-choice",
      "options": [
        "Компонент, разделенный на несколько частей или файлов",
        "Метод оптимизации",
        "Компонент с множеством пропсов",
        "Тип компонента"
      ],
      "correctAnswer": 0
    },
    {
      "id": "react-47",
      "text": "Что делает useCallback?",
      "type": "multiple-choice",
      "options": [
        "Создает callback",
        "Обрабатывает события",
        "Мемоизирует значение",
        "Мемоизирует функцию, предотвращая её пересоздание"
      ],
      "correctAnswer": 3
    },
    {
      "id": "react-48",
      "text": "Что делает useMemo?",
      "type": "multiple-choice",
      "options": [
        "Обрабатывает память",
        "Мемоизирует функцию",
        "Мемоизирует результат вычисления",
        "Создает мемо"
      ],
      "correctAnswer": 2
    },
    {
      "id": "react-49",
      "text": "Что делает useLayoutEffect?",
      "type": "multiple-choice",
      "options": [
        "Устарел",
        "Выполняется асинхронно",
        "Выполняется синхронно после DOM-мутаций, но до отрисовки",
        "Выполняется только на сервере"
      ],
      "correctAnswer": 2
    },
    {
      "id": "react-50",
      "text": "Как отрендерить HTML код в React-компоненте?",
      "type": "multiple-choice",
      "options": [
        "Нельзя",
        "Только через библиотеки",
        "Автоматически",
        "Использовать dangerouslySetInnerHTML"
      ],
      "correctAnswer": 3
    },
    {
      "id": "react-51",
      "text": "Зачем в setState нужно передавать функцию?",
      "type": "multiple-choice",
      "options": [
        "Когда новое состояние зависит от предыдущего",
        "Только для оптимизации",
        "Всегда нужно передавать функцию",
        "Не нужно передавать функцию"
      ],
      "correctAnswer": 0
    },
    {
      "id": "react-52",
      "text": "Для чего предназначен registerServiceWorker?",
      "type": "multiple-choice",
      "options": [
        "Устарел",
        "Для регистрации Service Worker для офлайн-функциональности",
        "Для регистрации событий",
        "Для регистрации компонентов"
      ],
      "correctAnswer": 1
    },
    {
      "id": "react-53",
      "text": "Чем React Router отличается от обычной маршрутизации?",
      "type": "multiple-choice",
      "options": [
        "React Router только для сервера",
        "Нет отличий",
        "React Router работает на клиенте без перезагрузки страницы",
        "React Router медленнее"
      ],
      "correctAnswer": 2
    },
    {
      "id": "react-54",
      "text": "Какие хуки были добавлены в React Router версии 5?",
      "type": "multiple-choice",
      "options": [
        "useHistory, useLocation, useParams, useRouteMatch",
        "useNavigate, useMatch",
        "Нет хуков",
        "useRouter, useRoute"
      ],
      "correctAnswer": 0
    },
    {
      "id": "react-55",
      "text": "Как передавать пропсы в React Router?",
      "type": "multiple-choice",
      "options": [
        "Через element в Route, через state в навигации, через render prop",
        "Только через state",
        "Нельзя передавать",
        "Только через пропсы"
      ],
      "correctAnswer": 0
    },
    {
      "id": "react-56",
      "text": "Что такое Reselect?",
      "type": "multiple-choice",
      "options": [
        "Метод выбора",
        "Тип компонента",
        "Библиотека для маршрутизации",
        "Библиотека для создания мемоизированных селекторов в Redux"
      ],
      "correctAnswer": 3
    },
    {
      "id": "react-57",
      "text": "Основная цель React Fiber?",
      "type": "multiple-choice",
      "options": [
        "Устарел",
        "Только для сервера",
        "Только оптимизация",
        "Инкрементальный рендеринг, приоритизация обновлений, возможность прерывания"
      ],
      "correctAnswer": 3
    },
    {
      "id": "react-58",
      "text": "Какие типы данных может возвращать render?",
      "type": "multiple-choice",
      "options": [
        "Только строки",
        "Только объекты",
        "Только JSX",
        "JSX-элементы, массивы, фрагменты, строки, числа, null, boolean"
      ],
      "correctAnswer": 3
    },
    {
      "id": "react-59",
      "text": "Разница между memo и useMemo?",
      "type": "multiple-choice",
      "options": [
        "useMemo устарел",
        "memo быстрее useMemo",
        "memo мемоизирует компонент, useMemo мемоизирует значение",
        "Нет разницы"
      ],
      "correctAnswer": 2
    },
    {
      "id": "react-60",
      "text": "Что такое SyntheticEvent?",
      "type": "multiple-choice",
      "options": [
        "Событие только для мобильных",
        "Асинхронное событие",
        "Обертка над нативным событием для кроссбраузерной совместимости",
        "Специальное событие React"
      ],
      "correctAnswer": 2
    },
    {
      "id": "react-61",
      "text": "Является ли React реактивным?",
      "type": "multiple-choice",
      "options": [
        "Не реактивный",
        "Не полностью, использует явные обновления и однонаправленный поток",
        "Да, полностью реактивный",
        "Только частично"
      ],
      "correctAnswer": 1
    },
    {
      "id": "react-62",
      "text": "Техники оптимизации производительности React?",
      "type": "multiple-choice",
      "options": [
        "Только мемоизация",
        "Только ленивая загрузка",
        "Мемоизация, ленивая загрузка, виртуализация, код-сплиттинг",
        "Нет техник"
      ],
      "correctAnswer": 2
    },
    {
      "id": "react-63",
      "text": "Лучшие практики безопасности в React?",
      "type": "multiple-choice",
      "options": [
        "Нет практик",
        "Только защита от XSS",
        "Защита от XSS, валидация данных, безопасные API-запросы, защита от CSRF",
        "Только валидация"
      ],
      "correctAnswer": 2
    },
    {
      "id": "react-64",
      "text": "Как работает пропс children в React?",
      "type": "multiple-choice",
      "options": [
        "Специальный проп для дочерних элементов, переданных компоненту",
        "Тип данных",
        "Метод компонента",
        "Библиотека"
      ],
      "correctAnswer": 0
    },
    {
      "id": "react-65",
      "text": "Что такое обратный поток данных в React?",
      "type": "multiple-choice",
      "options": [
        "Только через props",
        "Автоматическая передача",
        "Передача данных от дочернего компонента к родительскому через callbacks",
        "Не существует"
      ],
      "correctAnswer": 2
    },
    {
      "id": "react-66",
      "text": "Как использовать React.lazy и React.Suspense?",
      "type": "multiple-choice",
      "options": [
        "React.lazy для ленивой загрузки, Suspense для fallback UI",
        "Только Suspense",
        "Только React.lazy",
        "Нельзя использовать вместе"
      ],
      "correctAnswer": 0
    },
    {
      "id": "react-67",
      "text": "Что такое Hydration?",
      "type": "multiple-choice",
      "options": [
        "Библиотека",
        "Тип компонента",
        "Метод гидратации",
        "Процесс оживления статического HTML, отрендеренного на сервере"
      ],
      "correctAnswer": 3
    },
    {
      "id": "react-68",
      "text": "Разница между контролируемым и неконтролируемым компонентами?",
      "type": "multiple-choice",
      "options": [
        "Контролируемые быстрее",
        "Нет разницы",
        "Неконтролируемые устарели",
        "Контролируемые управляются React через state, неконтролируемые через DOM"
      ],
      "correctAnswer": 3
    },
    {
      "id": "react-69",
      "text": "Что такое компонент-переключатель (Switching Component)?",
      "type": "multiple-choice",
      "options": [
        "Компонент для переключения тем",
        "Компонент, который условно рендерит разные дочерние компоненты",
        "Тип компонента",
        "Метод оптимизации"
      ],
      "correctAnswer": 1
    },
    {
      "id": "react-70",
      "text": "Что такое useImperativeHandle?",
      "type": "multiple-choice",
      "options": [
        "Метод обработки событий",
        "Тип компонента",
        "Библиотека для refs",
        "Хук для настройки значения ref, передаваемого родительскому компоненту"
      ],
      "correctAnswer": 3
    }
  ]
}

